type t = { fmt : Format.formatter; buffer : Buffer.t }

let v () =
  let buffer = Buffer.create 1024 in
  let fmt = Format.formatter_of_buffer buffer in
  { buffer; fmt }

(* Normalize path by removing leading ./ *)
let normalize_path path =
  if String.starts_with ~prefix:"./" path then
    String.sub path 2 (String.length path - 2)
  else path

let contents t =
  Format.pp_print_flush t.fmt ();
  Buffer.contents t.buffer

let add_comment t text = Fmt.pf t.fmt "# %s@." text
let add_variable t name value = Fmt.pf t.fmt "%s = %s@." name value

let add_target t ~name ~deps ~commands =
  Fmt.pf t.fmt "@.%s:%a@." name
    (Fmt.list ~sep:(Fmt.any " ") Fmt.string)
    (if List.is_empty deps then [] else " " :: deps);
  List.iter (fun cmd -> Fmt.pf t.fmt "\t%s@." cmd) commands

let add_phony t targets =
  if not (List.is_empty targets) then
    Fmt.pf t.fmt "@..PHONY:%a@."
      (Fmt.list ~sep:(Fmt.any " ") Fmt.string)
      (" " :: targets)

let c_flags b =
  Hashtbl.find_opt b.Build.compiler_flags "c"
  |> Option.value ~default:(Flags.v ())

let generate_for_builds builds =
  if List.is_empty builds then Fmt.failwith "no targets found"
  else
    let makefile = v () in
    add_comment makefile "Generated by zenon";

    (* Variables *)
    add_variable makefile "COMPILER" "clang";
    add_variable makefile "CXX" "clang++";

    (* Collect all target names *)
    let target_names =
      List.map
        (fun (b : Build.t) ->
          match b.output with
          | Some s -> Eio.Path.native_exn s |> Filename.basename
          | None -> b.name)
        builds
    in

    (* Default target builds all targets *)
    add_target makefile ~name:"all" ~deps:target_names ~commands:[];

    (* Generate rules for each build target *)
    List.iter
      (fun (b : Build.t) ->
        let target_name =
          match b.output with
          | Some s -> Eio.Path.native_exn s |> Filename.basename
          | None -> b.name
        in

        let source_files = Build.locate_source_files b in
        let objects =
          List.map
            (fun src ->
              Object_file.of_source ~root:b.source ~build_name:b.name
                ~build_dir:Eio.Path.(b.build / "obj")
                src)
            source_files
        in

        (* Collect all linker flags from all file types *)
        let all_link_flags = ref b.flags.link in
        let visited_exts = Hashtbl.create 8 in

        List.iter
          (fun src ->
            let ext = Source_file.ext src in
            if not (Hashtbl.mem visited_exts ext) then (
              Hashtbl.add visited_exts ext true;
              match Hashtbl.find_opt b.compiler_flags ext with
              | Some comp_flags ->
                  all_link_flags := !all_link_flags @ comp_flags.link
              | None -> ()))
          source_files;

        (* Add pkg-config flags *)
        let pkg = Pkg_config.flags ~env:b.env b.pkgconf in
        all_link_flags := !all_link_flags @ pkg.link;

        let obj_paths =
          List.map
            (fun x -> normalize_path (Eio.Path.native_exn x.Object_file.path))
            objects
        in

        (* Determine dependencies on other targets *)
        let deps =
          List.filter_map
            (fun dep_name ->
              List.find_opt (fun (d : Build.t) -> d.name = dep_name) builds
              |> Option.map (fun (dep_b : Build.t) ->
                     match dep_b.output with
                     | Some s -> Eio.Path.native_exn s |> Filename.basename
                     | None -> dep_b.name))
            b.depends_on
        in

        (* Link target *)
        let link_flags = Flags.v ~link:!all_link_flags () in
        let linker =
          Linker.auto_select_linker ~sources:source_files ~linker:b.linker ()
        in
        let link_cmd =
          linker.command ~flags:link_flags ~objs:objects
            ~output:Eio.Path.(b.env#fs / target_name)
        in
        let link_cmd_str =
          String.concat " "
            (List.map
               (fun s -> if String.contains s ' ' then Filename.quote s else s)
               link_cmd)
          ^ if List.is_empty deps then "" else " " ^ String.concat " " deps
        in
        add_target makefile ~name:target_name ~deps:(obj_paths @ deps)
          ~commands:[ link_cmd_str ];

        (* Generate individual build rules for each object file *)
        (* For non-parallel builds, track previous object files by extension for ordering *)
        let prev_objs_by_ext = Hashtbl.create 8 in
        List.iter2
          (fun src obj ->
            let src_path = Eio.Path.native_exn src.Source_file.path in
            let obj_path =
              normalize_path (Eio.Path.native_exn obj.Object_file.path)
            in
            let obj_dir = Filename.dirname obj_path in
            let ext = Source_file.ext src in

            (* For non-parallel builds, add dependency on previous file of same extension *)
            let extra_deps =
              if not b.parallel then
                match Hashtbl.find_opt prev_objs_by_ext ext with
                | Some prev_obj -> [ prev_obj ]
                | None -> []
              else []
            in

            (* Determine compiler based on extension *)
            match Hashtbl.find_opt b.compiler_index ext with
            | Some c ->
                (* Get extension-specific flags only *)
                let ext_flags =
                  Hashtbl.find_opt b.compiler_flags ext
                  |> Option.value ~default:(Flags.v ())
                in
                (* Only add pkg-config flags, not the global b.flags which may be C-specific *)
                let final_flags =
                  Flags.concat ext_flags (Pkg_config.flags ~env:b.env b.pkgconf)
                in
                let compile_cmd =
                  c.command ~flags:final_flags ~sources:[ src ] ~output:obj
                in
                let compile_cmd_str =
                  String.concat " "
                    (List.map
                       (fun s ->
                         if String.contains s ' ' then Printf.sprintf "\"%s\"" s
                         else s)
                       compile_cmd)
                in
                let commands =
                  [ Printf.sprintf "@mkdir -p %s" obj_dir; compile_cmd_str ]
                in
                add_target makefile ~name:obj_path
                  ~deps:(src_path :: extra_deps) ~commands;
                if not b.parallel then
                  Hashtbl.replace prev_objs_by_ext ext obj_path
            | None ->
                (* Fallback for unknown extensions - use base build flags *)
                let commands =
                  [
                    Printf.sprintf "@mkdir -p %s" obj_dir;
                    Printf.sprintf "clang %s -c %s -o %s"
                      (String.concat " " b.flags.compile)
                      src_path obj_path;
                  ]
                in
                add_target makefile ~name:obj_path
                  ~deps:(src_path :: extra_deps) ~commands;
                if not b.parallel then
                  Hashtbl.replace prev_objs_by_ext ext obj_path)
          source_files objects)
      builds;

    (* Clean target *)
    add_target makefile ~name:"clean" ~deps:[]
      ~commands:
        [
          "rm -rf zenon-build";
          Printf.sprintf "rm -f %s" (String.concat " " target_names);
        ];

    add_phony makefile ("all" :: "clean" :: target_names);

    contents makefile
